# GC学习

### 一：概念

GC，Garbage Collection，垃圾回收

功能

- 找到内存中的垃圾
- 回收垃圾

#### 为什么需要GC

如果没有GC，程序员需要手动进行内存管理，开发麻烦，容易引发内存泄漏、野指针，而且因此导致的BUG很难被定位，修复麻烦

如果有GC，就可以避免这些问题

#### GC的种类

- 标记清除法
- 引用计数法
- GC复制法

#### GC的选取

- 最大暂停时间短：游戏
- 整体处理时间短：音频编码

#### 对象

这里的对象并不是OOP里的Object，而是**被应用程序使用的数据的集合**，对象由**头**和**域**构成

- 头（header）：包含对象的大小和种类

- 域（field）：参考OOP里的成员

对象分为活动对象和非活动对象，GC会保留活动对象，销毁非活动对象

#### mutator

可以简单理解为应用程序，在程序运行过程中，会分配/调用/改变对象（只能操作活动对象），伴随着mutator运行，会产生垃圾

#### GC算法的评估标准

- 吞吐量（throughput）：单位时间的处理能力
- 最大暂停时间（在进行GC时，mutator会被暂停）
- 堆使用效率
- 访问局部性

### 二：标记清除法

*学这一节之前想想操作系统里文件系统*

该算法分为两步

1. 标记阶段：将所有活动对象做上标记
2. 清除阶段：将所有没被标记的对象回收

#### 标记阶段

1. 通过根，找到直接引用的对象，标记
2. 递归标记所有能访问到的对象（常用深搜，因为内存使用量更少）

```c++
void mark(obj){
	if(!obj.mark) 
        obj.mark = true;
	for(child: obj.children) 
        mark(*child);
}
```

#### 清除阶段

遍历堆，回收所有没有被标记的对象，并将其放入空闲链表，以备分配

#### 分配策略

在创建新对象`obj`时，遍历空闲链表，寻找合适的块，这里使用First-fit算法（因为快）

- First-fit：找到第一个能放下`obj`的块
- Best-fit：找到最小的能放下`obj`的块
- Worst-fit：找到最大的能放下`obj`的块

#### 合并策略

分配和回收会导致大量小的分块，于是需要合并，在这里直接遍历堆，将连续的空闲块合并

#### 评价

优点

- 实现简单
- 与保守式GC兼容（因为对象不会被移动）

缺点

- 碎片化，导致空间浪费，访问性能降低
- 不支持**写时复制**（比如UNIX中的`fork()`）

#### 优化方案

- 分级空闲链表：使用多个空闲链表，分别只连接不同大小的分块，分配时先找所对应的区间，可以提高性能
- BiBOP（Big Bag Of Pages）：将大小相近的对象整理成固定大小的块进行管理
  - 碎片化的原因之一是杂乱散布的大小各异的对象，如果将堆固定分割，就可以减缓碎片化
- 位图标记：不直接堆对象进行标记，而是记录对象的标志位，存储在一个表格中
  - 与写时复制技术兼容（因为不会修改对象本身，可以复用）
  - 清除标志位更高效（只需要把表中要清除的对象的标志位改成一个特殊值）
- 延迟标记清除法
  - 分配时，先调用清除，如果能清出足够的空间来分配，则直接分配，否则进行普通的标记操作
  - 清除时，同样是First-fit遍历堆，但遍历的起点是上次开始的地点的右侧
  - 延迟的内核是不主动清除，而是等到要分配时再清除

### 三：引用计数法

*学这一节前，想想智能指针*

引用计数法中，对象会记录自己被引用次数，主要分为两个阶段

1. 创建新对象：分配内存，将对象引用次数设为1
2. 更新指针：先增后减计数器值，若引用次数为0则回收

```c++
//更新指针ptr，让其指向obj
void update_ptr(ptr, obj){	
	inc_ref_cnt(obj);	//obj要被ptr引用了，所以obj计数值++
    dec_ref_cnt(*ptr);	//ptr之前引用的东西不再被引用
    *ptr = obj;
}
void dec_ref_cnt(obj){
    obj.ref_cnt--;	//obj不再被引用，所以计数值--
    if(obj.ref_cnt == 0){	//如果obj没人用了，obj就要被清除
        for(child: obj.children){	//obj被清除了，那obj引用的对象，被引用次数要--
            dec_ref_cnt(*child);
        }
        reclaim(obj);	//执行回收
    }
}
```

#### 评价

优点：

- 对象变成垃圾时立刻被回收（延迟标记清除算法要等到分块用尽后才开始回收垃圾）
- 最大暂停时间短（只有在更新指针的时候才会打断mutator）
- 减少延根指针遍历所有子节点的次数（尤其在分布式系统中，效果显著）

缺点

- 频繁进行计数值的操作
- 计数器本身空间比较大（32位系统的计数器就要32位大小）
- **循环引用无法回收**
  - 如果两个物体互相引用，并不和其他对象有联系，于是他们成为了一座“孤岛”，成为了事实意义上的垃圾，但是却无法被回收（因为只要被引用，就不算垃圾）

#### 优化方案

- 延迟引用计数法
