# GC学习

### 一：概念

GC，Garbage Collection，垃圾回收

功能

- 找到内存中的垃圾
- 回收垃圾

#### 为什么需要GC

如果没有GC，程序员需要手动进行内存管理，开发麻烦，容易引发内存泄漏、野指针，而且因此导致的BUG很难被定位，修复麻烦

如果有GC，就可以避免这些问题

#### GC的种类

- 标记清除法
- 引用计数法
- GC复制法

#### GC的选取

- 最大暂停时间短：游戏
- 整体处理时间短：音频编码

#### 对象

这里的对象并不是OOP里的Object，而是**被应用程序使用的数据的集合**，对象由**头**和**域**构成

- 头（header）：包含对象的大小和种类

- 域（field）：参考OOP里的成员

对象分为活动对象和非活动对象，GC会保留活动对象，销毁非活动对象

#### mutator

可以简单理解为应用程序，在程序运行过程中，会分配/调用/改变对象（只能操作活动对象），伴随着mutator运行，会产生垃圾

#### GC算法的评估标准

- 吞吐量（throughput）：单位时间的处理能力
- 最大暂停时间（在进行GC时，mutator会被暂停）
- 堆使用效率
- 访问局部性

### 二：标记清除法

该算法分为两步

1. 标记阶段：将所有活动对象做上标记
2. 清除阶段：将所有没被标记的对象回收

#### 标记阶段

1. 通过根，找到直接引用的对象，标记
2. 递归标记所有能访问到的对象（常用深搜，因为内存使用量更少）

```c++
void mark(obj){
	if(!obj.mark) 
        obj.mark = true;
	for(child: obj.children) 
        mark(*child);
}
```

#### 清除阶段

遍历堆，回收所有没有被标记的对象，并将其放入空闲链表，以备分配

#### 分配策略

在创建新对象`obj`时，遍历空闲链表，寻找合适的块，这里使用First-fit算法（因为快）

- First-fit：找到第一个能放下`obj`的块
- Best-fit：找到最小的能放下`obj`的块
- Worst-fit：找到最大的能放下`obj`的块

#### 合并策略

分配和回收会导致大量小的分块，于是需要合并，在这里直接遍历堆，将连续的空闲块合并

#### 评价

优点

- 实现简单
- 与保守式GC兼容（因为对象不会被移动）

缺点

- 碎片化，导致空间浪费，访问性能降低
- 不支持**写时复制**（比如UNIX中的`fork()`）

#### 优化方案

- 分级空闲链表：使用多个空闲链表，分别只连接不同大小的分块，分配时先找所对应的区间，可以提高性能
- BiBOP（Big Bag Of Pages）：将大小相近的对象整理成固定大小的块进行管理
  - 碎片化的原因之一是杂乱散布的大小各异的对象，如果将堆固定分割，就可以减缓碎片化
- 位图标记：不直接堆对象进行标记，而是记录对象的标志位，存储在一个表格中
  - 与写时复制技术兼容（因为不会修改对象本身，可以复用）
  - 清除标志位更高效（只需要把表中要清除的对象的标志位改成一个特殊值）
- 延迟清除
  - 分配时，先调用清除，如果能清出足够的空间来分配，则直接分配，否则进行普通的标记操作
  - 清除时，同样是First-fit遍历堆，但遍历的起点是上次开始的地点的右侧
  - 延迟的内核是不主动清除，而是等到要分配时再清除

### 三：引用计数法











